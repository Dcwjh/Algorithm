# 字串和子序列的概念
字串和子数组必须事连续的
子序列可以是连续的，也可以是不连续的
KMP解决的是字串（连续字串的问题）


# KMP算法
- 核心思想
最长前缀和最长后缀的匹配长度。加速字符串的匹配速度，减少比较次数。
约定：前缀不能到最后一个字符，后缀不能到第一个字符。（若能取就不用求解了，就是整体的长度了）
例如：
abcabcd -->其中d字符的最长子串（abcabc）匹配长度是3
a x c
ab  x  bc
abc √  abc
abca x  cabc
abcab x bcabc
最后一个不符合约定
aaaaab ---> b的最长子串（aaaaa)匹配长度是4


# KMP算法应用
一颗二叉树树是否包含另一个二叉树树 ===》 树序列化===》KMP
树的序列化可以总结一下


# 最长回文序列长度
暴力解：简单的方法是扩充字符串比如求11311字符串的最长回文子序列长度，扩充为 ` #1#1#3#1#1#`。求出最大长度/2就是最大回文子序列。为什么要扩充，以为字符串长度为偶数的时候没有中心轴，容易在求解过程中忽略。

回文字符串以其长度来分，可以分为奇回文（其长度为奇数）、偶回文（其长度为偶数），一般情况下需要分两种情况来寻找回文，马拉车算法为了简化这一步，对原始字符串进行了处理，在每一个字符的左右两边都加上特殊字符（肯定不存在于原字符串中的字符），让字符串变成一个奇回文。例如：

原字符串：abba，长度为4
预处理后：#a#b#b#a#，长度为9

原字符串：aba，长度为3
预处理后：#a#b#a#，长度为7

https://www.jianshu.com/p/392172762e55


## 动态规划
![动态规划思路](./dongtaiguihua.png)
### 第 1 步：定义状态：
`dp[i][j]` 表示子串 `s`[i..j]` 是否为回文子串，这里子串 `s[i..j]` 定义为左闭右闭区间，可以取到 `s[i]` 和 `s[j]`。

### 第 2 步：思考状态转移方程
`dp[i][j] = (s[i] == s[j]) and dp[i + 1][j - 1]`
说明：
- 「动态规划」事实上是在填一张二维表格，由于构成子串，因此 i 和 j 的关系是 i <= j ，因此，只需要填这张表格对角线以上的部分。
- 看到 `dp[i + 1][j - 1]` 就得考虑边界情况。

边界条件是：表达式 `[i + 1, j - 1]` 不构成区间，即长度严格小于 2，即 `j - 1 - (i + 1) + 1 < 2` ，整理得 `j - i < 3`。
这个结论很显然：`j - i < 3` 等价于 `j - i + 1 < 4`，即当子串 `s[i..j]` 的长度等于 2 或者等于 3 的时候，其实只需要判断一下头尾两个字符是否相等就可以直接下结论了。
- 如果子串 s[i + 1..j - 1] 只有 1 个字符，即去掉两头，剩下中间部分只有 1个字符，显然是回文；
- 如果子串 s[i + 1..j - 1] 为空串，那么子串 s[i, j] 一定是回文子串。
因此，在 s[i] == s[j] 成立和 j - i < 3 的前提下，直接可以下结论，dp[i][j] = true，否则才执行状态转移。

### 第 3 步：考虑初始化
初始化的时候，单个字符一定是回文串，因此把对角线先初始化为 true，即 dp[i][i] = true 。

事实上，初始化的部分都可以省去。因为只有一个字符的时候一定是回文，dp[i][i] 根本不会被其它状态值所参考。

### 第 4 步：考虑输出
只要一得到 dp[i][j] = true，就记录子串的长度和起始位置，没有必要截取，这是因为截取字符串也要消耗性能，记录此时的回文子串的「起始位置」和「回文长度」即可。

### 第 5 步：考虑优化空间
因为在填表的过程中，只参考了左下方的数值。事实上可以优化，但是增加了代码编写和理解的难度，丢失可读和可解释性。在这里不优化空间。

注意事项：总是先得到小子串的回文判定，然后大子串才能参考小子串的判断结果，即填表顺序很重要。


状态有效性：当前状态是根据数据的左下角计算出来的，因此需要先要确定左下角的状态。

## Manacher's Algorithm 马拉车算法
最长回文子串半径
最右边界


